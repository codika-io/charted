---
title: "Data Science"
description: "The extraction of knowledge from data — statistical analysis, data mining, visualization, and the data science pipeline."
parent: computer-science/data-and-information
order: 3
color: "#3b82f6"
difficulty: intermediate
prerequisites: ["computer-science/data-and-information/databases", "computer-science/theoretical-foundations/algorithms-and-complexity"]
status: draft
author: agent
lastEditedBy: agent
lastUpdated: "2026-02-28"
---

Data science is the discipline concerned with extracting knowledge and actionable insight from data through a combination of statistical analysis, algorithmic pattern discovery, and visual communication. It sits at the intersection of computer science, statistics, and domain expertise, drawing on databases for storage and retrieval, on algorithms for computational efficiency, and on probability theory for principled reasoning under uncertainty. The modern data science pipeline — from raw data acquisition through cleaning, exploration, modeling, and interpretation — has become indispensable across virtually every field of human endeavor.

## Data Acquisition and Exploratory Analysis

Every data science project begins with data, and the first challenge is obtaining it in a usable form. Data arrives from databases, application programming interfaces (APIs), sensor networks, web scraping, log files, surveys, and countless other sources, each with its own format, granularity, and quality characteristics. **Data profiling** — the systematic examination of a dataset's structure, completeness, and value distributions — is the essential first step toward understanding what the data contains and what problems it presents. Common quality issues include missing values, duplicate records, inconsistent formats, and data entry errors, all of which must be identified before any analysis can proceed.

**Exploratory Data Analysis (EDA)**, a methodology championed by **John Tukey** in his influential 1977 book of the same name, emphasizes the use of visual and quantitative summaries to develop intuition about data before applying formal models. Tukey argued that premature formalization — jumping straight to hypothesis testing without first looking at the data — was a recipe for missed insights and misleading conclusions. The toolkit of EDA includes **summary statistics** (mean, median, variance, skewness, kurtosis), **histograms** and **density plots** for visualizing distributions, **box plots** for identifying outliers and comparing groups, **scatter plots** for examining bivariate relationships, and **correlation matrices** for surveying pairwise associations among many variables. The **correlation coefficient** $r$ between two variables $X$ and $Y$ is defined as:

$$r = \frac{\sum_{i=1}^{n}(x_i - \bar{x})(y_i - \bar{y})}{\sqrt{\sum_{i=1}^{n}(x_i - \bar{x})^2 \cdot \sum_{i=1}^{n}(y_i - \bar{y})^2}}$$

where $\bar{x}$ and $\bar{y}$ are the sample means. Values near $+1$ or $-1$ indicate strong linear association, while values near $0$ indicate weak linear association — though not necessarily independence, since $r$ measures only linear relationships. More advanced exploratory techniques include **quantile-quantile (Q-Q) plots** for assessing distributional assumptions, **parallel coordinate plots** for visualizing high-dimensional data, and **principal component analysis (PCA) biplots** for simultaneous visualization of observations and variables in reduced dimensions. The philosophy of EDA remains foundational: look at the data, question assumptions, and let patterns emerge before imposing structure.

## Data Preprocessing and Cleaning

Raw data is almost never ready for analysis. **Data preprocessing** transforms messy, heterogeneous inputs into a clean, consistent format suitable for modeling, and it routinely consumes the majority of effort in a data science project. The specific transformations required depend on the data and the intended analysis, but several categories of preprocessing are nearly universal.

**Missing data** is ubiquitous, and its treatment depends on the mechanism that generated it. Data that is **missing completely at random (MCAR)** — where the probability of missingness is unrelated to any observed or unobserved values — can be handled by simple deletion without introducing bias, though with a loss of statistical power. Data that is **missing at random (MAR)** — where missingness depends on observed values but not on the missing values themselves — requires model-based imputation to avoid bias. Data that is **missing not at random (MNAR)** — where the probability of missingness depends on the missing values — is the most problematic and requires explicit modeling of the missingness mechanism. Imputation methods range from simple strategies (replacing missing values with the column mean or median) to sophisticated model-based approaches such as **k-nearest neighbor (KNN) imputation** (which fills in missing values using the values of the most similar complete observations) and **Multiple Imputation by Chained Equations (MICE)** (which creates multiple plausible imputations by iteratively modeling each variable conditional on all others).

**Feature scaling** ensures that variables measured on different scales do not distort algorithms that are sensitive to magnitude. **Z-score standardization** transforms each variable to have zero mean and unit variance: $z = (x - \mu) / \sigma$. **Min-max normalization** rescales values to a fixed range, typically $[0, 1]$: $x' = (x - x_{\min}) / (x_{\max} - x_{\min})$. **Robust scaling** uses the median and interquartile range instead, making it less sensitive to outliers. **Categorical encoding** converts non-numerical variables into numerical representations. **One-hot encoding** creates a binary column for each category, while **ordinal encoding** assigns integers to ordered categories. **Target encoding** replaces each category with the mean of the target variable for that category, introducing a risk of overfitting that must be managed through regularization or cross-validation.

**Outlier detection** identifies observations that deviate substantially from the rest of the data. Statistical methods flag values beyond a threshold number of standard deviations from the mean, while more sophisticated approaches such as the **isolation forest** algorithm (which isolates outliers by randomly partitioning the feature space, under the insight that outliers require fewer partitions to isolate) and the **Local Outlier Factor (LOF)** (which compares the local density of each point to that of its neighbors) can detect outliers in multivariate and non-Gaussian settings. The treatment of outliers — deletion, transformation, or retention — depends on whether they represent errors, rare but genuine phenomena, or the very events of interest (as in fraud detection).

## Clustering and Unsupervised Pattern Discovery

**Clustering** is the task of partitioning data into groups of similar objects without prior knowledge of the group labels. It is the prototypical unsupervised learning problem and one of the oldest topics in data analysis, with applications ranging from customer segmentation and image compression to gene expression analysis and document organization.

The most widely used clustering algorithm is **k-means**, which partitions $n$ observations into $k$ clusters by iteratively assigning each observation to the cluster with the nearest centroid and then recomputing the centroids as the mean of their assigned observations. The algorithm converges to a local minimum of the within-cluster sum of squared distances, but the result depends on the initial placement of centroids. **K-means++**, proposed by David Arthur and Sergei Vassilvitskii in 2007, addresses this with a careful initialization scheme that spreads the initial centroids apart, providing a provable approximation guarantee. The choice of $k$ is itself a modeling decision, guided by heuristics such as the **elbow method** (plotting the within-cluster sum of squares against $k$ and looking for a bend) and the **silhouette score** (which measures how similar each point is to its own cluster compared to the nearest neighboring cluster, with values ranging from $-1$ to $+1$).

**Density-based clustering** algorithms, most notably **DBSCAN** (Density-Based Spatial Clustering of Applications with Noise), developed by Martin Ester and colleagues in 1996, take a fundamentally different approach: a cluster is defined as a maximal set of density-connected points, where density is measured by the number of points within a radius $\varepsilon$ of each point. Points in low-density regions are classified as noise. DBSCAN discovers clusters of arbitrary shape, handles noise naturally, and does not require specifying the number of clusters in advance — advantages that k-means lacks — but it struggles with clusters of varying density. **OPTICS** (Ordering Points To Identify the Clustering Structure) extends DBSCAN by producing an ordering of points that captures the density-based clustering structure at all scales, effectively addressing the varying-density problem.

**Hierarchical clustering** builds a tree-like structure (a **dendrogram**) that represents a nested sequence of clusterings at different levels of granularity. **Agglomerative** hierarchical clustering starts with each point as its own cluster and iteratively merges the two most similar clusters according to a **linkage criterion**: **single linkage** (minimum distance between any two points in the two clusters), **complete linkage** (maximum distance), **average linkage** (mean distance), or **Ward's method** (merge that minimizes the total within-cluster variance). The dendrogram can be cut at any level to produce a flat partition, giving the analyst flexibility to explore structure at multiple scales. **Gaussian Mixture Models (GMMs)**, which model the data as a mixture of multivariate Gaussian distributions whose parameters are estimated by the **Expectation-Maximization (EM)** algorithm, provide a probabilistic alternative to hard clustering: each point has a probability of belonging to each cluster rather than a single assignment. Model selection criteria such as the **Bayesian Information Criterion (BIC)** and the **Akaike Information Criterion (AIC)** help determine the appropriate number of components.

## Classification and Supervised Pattern Discovery

**Classification** assigns each observation to one of a predefined set of categories based on its features. It is the central task of supervised learning in the data mining tradition, and the algorithms developed for classification have become foundational tools across all of data science.

**Decision trees** partition the feature space into axis-aligned regions by recursively splitting on the feature and threshold that best separate the classes. The **CART** algorithm (Classification and Regression Trees), introduced by Leo Breiman and colleagues in 1984, uses the **Gini impurity** as its splitting criterion: $G = 1 - \sum_{k=1}^{K} p_k^2$, where $p_k$ is the proportion of class $k$ in a node. An alternative criterion is **information gain**, based on **entropy** $H = -\sum_{k=1}^{K} p_k \log_2 p_k$, which measures the reduction in uncertainty achieved by a split. Decision trees are intuitive and interpretable — the resulting model can be read as a sequence of if-then rules — but they are prone to overfitting, which is controlled by **pruning** (removing branches that do not significantly improve classification accuracy on held-out data).

**K-nearest neighbors (KNN)** classifies an observation by a majority vote among its $k$ closest neighbors in the feature space, where closeness is measured by a distance metric such as Euclidean, Manhattan, or Minkowski distance. KNN is a **lazy learner** — it stores all training data and defers computation until prediction time — which makes it simple but expensive at prediction time for large datasets. The choice of $k$ balances bias (high $k$ smooths the decision boundary) against variance (low $k$ makes the boundary sensitive to individual training points).

**Support vector machines (SVMs)**, developed by Vladimir Vapnik and colleagues in the 1990s, find the hyperplane that separates two classes with the maximum **margin** — the distance from the hyperplane to the nearest training point of either class. The **kernel trick** allows SVMs to operate in implicitly high-dimensional feature spaces by replacing the dot product with a kernel function such as the radial basis function (RBF) kernel $K(x, x') = \exp(-\gamma \|x - x'\|^2)$, enabling nonlinear decision boundaries without explicit feature computation. The **Naive Bayes** classifier, rooted in Bayes' theorem $P(C|X) = P(X|C) P(C) / P(X)$, assumes that features are conditionally independent given the class — a simplification that is almost never literally true but that nonetheless produces surprisingly effective classifiers, especially for text categorization and spam filtering. Laplace smoothing prevents zero probabilities when a feature-class combination is absent from the training data.

## Association Rules and Frequent Pattern Mining

**Association rule mining** discovers interesting relationships among variables in large datasets. The canonical application is **market basket analysis**: given a database of customer transactions, find sets of items that are frequently purchased together. An **association rule** has the form $X \Rightarrow Y$, meaning "transactions containing item set $X$ tend to also contain item set $Y$."

The quality of an association rule is measured by several metrics. **Support** is the fraction of transactions containing both $X$ and $Y$: $\text{supp}(X \Rightarrow Y) = P(X \cup Y)$. **Confidence** is the conditional probability of $Y$ given $X$: $\text{conf}(X \Rightarrow Y) = P(Y | X) = \text{supp}(X \cup Y) / \text{supp}(X)$. **Lift** measures how much more likely $Y$ is when $X$ is present than it would be independently: $\text{lift}(X \Rightarrow Y) = \text{conf}(X \Rightarrow Y) / P(Y)$. A lift greater than 1 indicates a positive association, equal to 1 indicates independence, and less than 1 indicates a negative association.

The foundational algorithm for discovering frequent itemsets is **Apriori**, introduced by **Rakesh Agrawal** and Ramakrishnan Srikant in 1994. Apriori exploits the **downward closure property** (also called the Apriori principle): if an itemset is infrequent, then all of its supersets must also be infrequent. The algorithm proceeds level-wise, first finding all frequent individual items, then frequent pairs, then frequent triples, and so on, pruning candidates whose subsets are known to be infrequent. The **FP-Growth** algorithm, proposed by Jiawei Han and colleagues in 2000, avoids the expensive candidate generation step of Apriori by compressing the transaction database into a compact **FP-tree** (frequent pattern tree) and mining it directly through conditional pattern base construction. FP-Growth is typically much faster than Apriori, especially for dense datasets with long frequent patterns.

## Dimensionality Reduction

Real-world datasets often contain dozens, hundreds, or even thousands of features, many of which are redundant or irrelevant. **Dimensionality reduction** projects data from a high-dimensional space into a lower-dimensional space that preserves as much of the important structure as possible, improving computational efficiency, reducing noise, and enabling visualization.

**Principal Component Analysis (PCA)** is the most widely used linear dimensionality reduction technique. PCA finds the directions of maximum variance in the data by computing the eigenvectors of the covariance matrix (or equivalently, through singular value decomposition of the centered data matrix). The first principal component is the direction along which the data varies most, the second is the direction of maximum variance orthogonal to the first, and so on. The **explained variance ratio** of each component indicates how much of the total variance it captures, and the cumulative explained variance guides the choice of how many components to retain. For a data matrix $X$ with $n$ observations and $p$ features, PCA produces a transformation $Z = XW$, where the columns of $W$ are the eigenvectors (principal component loadings) and $Z$ contains the transformed observations in the reduced space.

**Linear Discriminant Analysis (LDA)**, unlike PCA, incorporates class label information and finds projections that maximize the ratio of between-class variance to within-class variance, making it a supervised dimensionality reduction technique. **Singular Value Decomposition (SVD)** provides the mathematical foundation for both PCA and many other techniques, expressing any matrix as a product $A = U \Sigma V^T$ of orthogonal matrices $U$ and $V$ and a diagonal matrix $\Sigma$ of singular values.

For data that lies on a nonlinear manifold, linear methods like PCA are insufficient. **t-SNE** (t-distributed Stochastic Neighbor Embedding), introduced by Laurens van der Maaten and Geoffrey Hinton in 2008, is a nonlinear technique that maps high-dimensional data to two or three dimensions for visualization by preserving local neighborhood structure. It models pairwise similarities as probabilities in both the high-dimensional and low-dimensional spaces and minimizes the Kullback-Leibler divergence between them, using a Student's $t$-distribution in the low-dimensional space to handle the "crowding problem" (the tendency for points to collapse together in low dimensions). **UMAP** (Uniform Manifold Approximation and Projection), developed by Leland McInnes and colleagues in 2018, achieves similar visualizations with better preservation of global structure and significantly faster computation, based on a theoretical framework rooted in Riemannian geometry and algebraic topology. **Feature selection** methods take a different approach to dimensionality reduction by choosing a subset of the original features rather than creating new ones. **Filter methods** rank features by statistical measures such as correlation or mutual information with the target variable. **Wrapper methods** evaluate subsets of features by training and testing a model on each subset. **Embedded methods** such as L1 regularization (Lasso) and tree-based feature importance perform feature selection as part of the model training process.

## Anomaly Detection and Time Series Analysis

**Anomaly detection** (also called outlier detection) identifies observations that deviate significantly from the expected pattern. Unlike the outlier handling in data preprocessing, which treats anomalies as noise to be removed, anomaly detection treats them as the signal of interest — the fraudulent transaction, the network intrusion, the manufacturing defect, or the disease outbreak. Anomaly detection methods can be statistical (flagging points whose probability under an assumed distribution is below a threshold), distance-based (flagging points that are far from their nearest neighbors in feature space), density-based (flagging points in regions of unusually low density, as in the Local Outlier Factor), or model-based (training a model on normal data and flagging points that the model assigns high reconstruction error, as in autoencoders).

**Time series analysis** addresses data collected sequentially over time, where temporal ordering and autocorrelation are essential features that standard methods ignore. A time series is typically decomposed into **trend** (long-term directional movement), **seasonality** (repeating patterns at fixed periods), and **residual** (random variation). **Stationarity** — the property that the statistical characteristics of the series do not change over time — is a key assumption of many models and is achieved through **differencing** (subtracting consecutive observations) or transformation. The **autocorrelation function (ACF)** and **partial autocorrelation function (PACF)** reveal the temporal dependency structure and guide model selection. The **ARIMA** (AutoRegressive Integrated Moving Average) family of models, building on the work of George Box and Gwilym Jenkins in their landmark 1970 text *Time Series Analysis: Forecasting and Control*, combines autoregressive terms (where the current value depends on past values), moving average terms (where the current value depends on past forecast errors), and differencing to model a wide range of stationary and non-stationary series. **Seasonal ARIMA (SARIMA)** extends the framework to series with seasonal patterns by adding seasonal autoregressive, differencing, and moving average components. More recent approaches include Facebook's **Prophet** model (designed for business forecasting with strong seasonal effects and holiday impacts), **LSTM** (Long Short-Term Memory) neural networks that learn temporal patterns from data, and attention-based sequence models built on the transformer architecture.

## Big Data and the Data Science Pipeline

The explosion of data volume, velocity, and variety in the twenty-first century — often summarized by the "three Vs" — has necessitated new computational frameworks for data science at scale. The **MapReduce** programming model, introduced by Jeffrey Dean and Sanjay Ghemawat at Google in 2004, provided a simple abstraction for distributed computation: a **map** function processes input key-value pairs to produce intermediate key-value pairs, and a **reduce** function merges all intermediate values associated with the same key. The open-source **Apache Hadoop** implementation of MapReduce, combined with the **Hadoop Distributed File System (HDFS)**, became the foundation of the big data ecosystem in the late 2000s.

**Apache Spark**, developed at UC Berkeley's AMPLab by Matei Zaharia and colleagues starting in 2009, superseded MapReduce for most workloads by introducing **Resilient Distributed Datasets (RDDs)** — immutable, partitioned collections of records that can be cached in memory across a cluster and transformed through a rich set of operations including map, filter, reduce, join, and aggregate. Spark's in-memory processing model is often orders of magnitude faster than MapReduce for iterative algorithms such as those used in machine learning. The Spark ecosystem includes **Spark SQL** for structured data processing, **MLlib** for distributed machine learning, and **Spark Streaming** for processing real-time data streams.

The modern data science pipeline integrates these tools into an end-to-end workflow. Data is ingested from diverse sources into a **data lake** (a centralized repository that stores raw data at any scale) or a **data warehouse** (an optimized store for structured analytical queries). Pipeline orchestration tools such as **Apache Airflow** schedule and monitor the sequence of extraction, transformation, loading, modeling, and reporting steps. **Data governance** frameworks ensure data quality, lineage tracking (knowing where data came from and how it was transformed), access control, and compliance with regulations such as GDPR and CCPA. **Ethical data science** — encompassing fairness, accountability, and transparency — has emerged as a critical concern, as decisions driven by data mining algorithms increasingly affect employment, lending, criminal justice, and healthcare. Understanding and mitigating bias in data, models, and their deployment is now recognized as an integral part of responsible data science practice, connecting the technical discipline to the broader social context in which it operates.
